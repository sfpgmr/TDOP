CONST = "const" 
BOOL = "bool"
FLOAT = "float"
INT = "int"
UINT = "uint"
BREAK = "break"
CONTINUE = "continue"
DO = "do"
ELSE = "else"
FOR = "for"
IF = "if"
DISCARD = "discard"
RETURN = "return"
SWITCH = "switch"
CASE = "case"
DEFAULT = "default"
BVEC2 = "bvec2"
BVEC3 = "bvec3"
BVEC4 = "bvec4"
IVEC2 = "ivec2"
IVEC3 = "ivec3"
IVEC4 = "ivec4"
UVEC2 = "uvec2"
UVEC3 = "uvec3"
UVEC4 = "uvec4"
VEC2 = "vec2"
VEC3 = "vec3"
VEC4 = "vec4"
MAT2 = "mat2"
MAT3 = "mat3"
MAT4 = "mat4"
CENTROID = "centroid"
IN = "in"
OUT = "out"
INOUT = "inout"
UNIFORM = "uniform"
FLAT = "flat"
SMOOTH = "smooth"
LAYOUT = "layout"
MAT2X2 = "mat2x2"
MAT2X3 = "mat2x3"
MAT2X4 = "mat2x4"
MAT3X2 = "mat3x2"
MAT3X3 = "mat3x3"
MAT3X4 = "mat3x4"
MAT4X2 = "mat4x2"
MAT4X3 = "mat4x3"
MAT4X4 = "mat4x4"
SAMPLER2D = "sampler2d"
SAMPLER3D = "sampler3d"
SAMPLERCUBE = "samplercube"
SAMPLER2DSHADOW = "sampler2dshadow"
SAMPLERCUBESHADOW = "samplercubeshadow"
SAMPLER2DARRAY = "sampler2darray"
SAMPLER2DARRAYSHADOW = "sampler2darrayshadow"
ISAMPLER2D = "isampler2d"
ISAMPLER3D = "isampler3d"
ISAMPLERCUBE = "isamplercube"
ISAMPLER2DARRAY = "isampler2darray"
USAMPLER2D = "usampler2d"
USAMPLER3D = "usampler3d"
USAMPLERCUBE = "usamplercube"
USAMPLER2DARRAY = "usampler2darray"

STRUCT = "struct"
VOID = "void"
WHILE = "while"
IDENTIFIER = "identifier"
TYPE_NAME = "type_name"
FLOATCONSTANT = "floatconstant"
INTCONSTANT = "intconstant"
UINTCONSTANT = "uintconstant"
BOOLCONSTANT = "boolconstant"
FIELD_SELECTION = "field_selection"
LEFT_OP = "<<"
RIGHT_OP = ">>"
INC_OP = "++"
DEC_OP = "--"
LE_OP = "<="
GE_OP = ">="
EQ_OP = "=="
NE_OP = "!="
AND_OP = "&&"
OR_OP = "||"
XOR_OP = "^^"
MUL_ASSIGN = "*="
DIV_ASSIGN = "/="
ADD_ASSIGN = "+="
MOD_ASSIGN = "%="
LEFT_ASSIGN = "<<="
RIGHT_ASSIGN = ">>="
AND_ASSIGN = "&="
XOR_ASSIGN = "^="
OR_ASSIGN = "|="
SUB_ASSIGN = "-="
LEFT_PAREN = "("
RIGHT_PAREN = ")"
LEFT_BRACKET = "["
RIGHT_BRACKET = "]"
LEFT_BRACE = "{"
RIGHT_BRACE = "}"
DOT = "."
COMMA = ","
COLON = ":"
EQUAL = "="
SEMICOLON = ";"
BANG = "!"
DASH = "'"
TILDE = "~"
PLUS = "+"
STAR = "*"
SLASH = "/"
PERCENT = "%"
LEFT_ANGLE = "<"
RIGHT_ANGLE = ">"
VERTICAL_BAR = "_"
CARET = "^"
AMPERSAND = "&"
QUESTION = "?"
INVARIANT = "invariant"
HIGH_PRECISION = "highp"
MEDIUM_PRECISION = "mediump"
LOW_PRECISION = "lowp"
PRECISION = "precision"

VARIABLE_IDENTIFIER = IDENTIFIER

PRIMARY_EXPRESSION =
 VARIABLE_IDENTIFIER /
 INTCONSTANT / 
 UINTCONSTANT / 
 FLOATCONSTANT / 
 BOOLCONSTANT / 
 LEFT_PAREN EXPRESSION RIGHT_PAREN 

POSTFIX_EXPRESSION =
 PRIMARY_EXPRESSION / 
 POSTFIX_EXPRESSION LEFT_BRACKET INTEGER_EXPRESSION RIGHT_BRACKET / 
 FUNCTION_CALL / 
 POSTFIX_EXPRESSION DOT FIELD_SELECTION / 
 POSTFIX_EXPRESSION INC_OP / 
 POSTFIX_EXPRESSION DEC_OP

INTEGER_EXPRESSION = 
 EXPRESSION

FUNCTION_CALL = 
 FUNCTION_CALL_OR_METHOD

FUNCTION_CALL_OR_METHOD = 
 FUNCTION_CALL_GENERIC / 
 POSTFIX_EXPRESSION DOT FUNCTION_CALL_GENERIC

FUNCTION_CALL_GENERIC = 
 FUNCTION_CALL_HEADER_WITH_PARAMETERS RIGHT_PAREN / 
 FUNCTION_CALL_HEADER_NO_PARAMETERS RIGHT_PAREN

FUNCTION_CALL_HEADER_NO_PARAMETERS = 
 FUNCTION_CALL_HEADER VOID /
 FUNCTION_CALL_HEADER

FUNCTION_CALL_HEADER_WITH_PARAMETERS = 
 FUNCTION_CALL_HEADER ASSIGNMENT_EXPRESSION / 
 FUNCTION_CALL_HEADER_WITH_PARAMETERS COMMA ASSIGNMENT_EXPRESSION

FUNCTION_CALL_HEADER = 
 FUNCTION_IDENTIFIER LEFT_PAREN
// Grammar Note =  Constructors look like functions, but lexical analysis recognized most of them as
// keywords. They are now recognized through “type_specifier”.
// Methods (.length) and identifiers are recognized through postfix_expression.

FUNCTION_IDENTIFIER = 
 TYPE_SPECIFIER / 
 IDENTIFIER / 
 FIELD_SELECTION 

UNARY_EXPRESSION = 
 POSTFIX_EXPRESSION / 
 INC_OP UNARY_EXPRESSION / 
 DEC_OP UNARY_EXPRESSION / 
 UNARY_OPERATOR UNARY_EXPRESSION

// Grammar Note =  No traditional style type casts.

UNARY_OPERATOR = 
 PLUS / 
 DASH /
 BANG /
 TILDE

// Grammar Note =  No '*' or '&' unary ops. Pointers are not supported.
MULTIPLICATIVE_EXPRESSION = 
 UNARY_EXPRESSION /
 MULTIPLICATIVE_EXPRESSION STAR UNARY_EXPRESSION / 
 MULTIPLICATIVE_EXPRESSION SLASH UNARY_EXPRESSION / 
 MULTIPLICATIVE_EXPRESSION PERCENT UNARY_EXPRESSION

ADDITIVE_EXPRESSION = 
 MULTIPLICATIVE_EXPRESSION / 
 ADDITIVE_EXPRESSION PLUS MULTIPLICATIVE_EXPRESSION / 
 ADDITIVE_EXPRESSION DASH MULTIPLICATIVE_EXPRESSION

SHIFT_EXPRESSION = 
 ADDITIVE_EXPRESSION / 
 SHIFT_EXPRESSION LEFT_OP ADDITIVE_EXPRESSION / 
 SHIFT_EXPRESSION RIGHT_OP ADDITIVE_EXPRESSION

RELATIONAL_EXPRESSION = 
 SHIFT_EXPRESSION / 
 RELATIONAL_EXPRESSION LEFT_ANGLE SHIFT_EXPRESSION / 
 RELATIONAL_EXPRESSION RIGHT_ANGLE SHIFT_EXPRESSION / 
 RELATIONAL_EXPRESSION LE_OP SHIFT_EXPRESSION / 
 RELATIONAL_EXPRESSION GE_OP SHIFT_EXPRESSION

EQUALITY_EXPRESSION = 
 RELATIONAL_EXPRESSION / 
 EQUALITY_EXPRESSION EQ_OP RELATIONAL_EXPRESSION / 
 EQUALITY_EXPRESSION NE_OP RELATIONAL_EXPRESSION

AND_EXPRESSION = 
 EQUALITY_EXPRESSION / 
 AND_EXPRESSION AMPERSAND EQUALITY_EXPRESSION

EXCLUSIVE_OR_EXPRESSION = 
 AND_EXPRESSION / 
 EXCLUSIVE_OR_EXPRESSION CARET AND_EXPRESSION

INCLUSIVE_OR_EXPRESSION = 
 EXCLUSIVE_OR_EXPRESSION /
 INCLUSIVE_OR_EXPRESSION VERTICAL_BAR EXCLUSIVE_OR_EXPRESSION

LOGICAL_AND_EXPRESSION = 
 INCLUSIVE_OR_EXPRESSION /
 LOGICAL_AND_EXPRESSION AND_OP INCLUSIVE_OR_EXPRESSION

LOGICAL_XOR_EXPRESSION = 
 LOGICAL_AND_EXPRESSION /
 LOGICAL_XOR_EXPRESSION XOR_OP LOGICAL_AND_EXPRESSION

LOGICAL_OR_EXPRESSION = 
 LOGICAL_XOR_EXPRESSION /
 LOGICAL_OR_EXPRESSION OR_OP LOGICAL_XOR_EXPRESSION

CONDITIONAL_EXPRESSION = 
 LOGICAL_OR_EXPRESSION /
 LOGICAL_OR_EXPRESSION QUESTION EXPRESSION COLON ASSIGNMENT_EXPRESSION 

ASSIGNMENT_EXPRESSION = 
 CONDITIONAL_EXPRESSION /
 UNARY_EXPRESSION ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION

ASSIGNMENT_OPERATOR = 
 EQUAL / 
 MUL_ASSIGN / 
 DIV_ASSIGN / 
 MOD_ASSIGN / 
 ADD_ASSIGN / 
 SUB_ASSIGN / 
 LEFT_ASSIGN / 
 RIGHT_ASSIGN / 
 AND_ASSIGN / 
 XOR_ASSIGN / 
 OR_ASSIGN

EXPRESSION = 
 ASSIGNMENT_EXPRESSION /
 EXPRESSION COMMA ASSIGNMENT_EXPRESSION

CONSTANT_EXPRESSION = 
 CONDITIONAL_EXPRESSION

DECLARATION = 
 FUNCTION_PROTOTYPE SEMICOLON / 
 INIT_DECLARATOR_LIST SEMICOLON / 
 PRECISION PRECISION_QUALIFIER TYPE_SPECIFIER_NO_PREC SEMICOLON / 
 TYPE_QUALIFIER IDENTIFIER LEFT_BRACE STRUCT_DECLARATION_LIST RIGHT_BRACE SEMICOLON / 
 TYPE_QUALIFIER IDENTIFIER LEFT_BRACE STRUCT_DECLARATION_LIST RIGHT_BRACE / 
 IDENTIFIER SEMICOLON / 
 TYPE_QUALIFIER IDENTIFIER LEFT_BRACE STRUCT_DECLARATION_LIST RIGHT_BRACE / 
 IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION RIGHT_BRACKET SEMICOLON / 
 TYPE_QUALIFIER SEMICOLON

FUNCTION_PROTOTYPE = 
 FUNCTION_DECLARATOR RIGHT_PAREN

FUNCTION_DECLARATOR = 
  FUNCTION_HEADER /
  FUNCTION_HEADER_WITH_PARAMETERS

FUNCTION_HEADER_WITH_PARAMETERS = 
 FUNCTION_HEADER PARAMETER_DECLARATION /
 FUNCTION_HEADER_WITH_PARAMETERS COMMA PARAMETER_DECLARATION

FUNCTION_HEADER = 
 FULLY_SPECIFIED_TYPE IDENTIFIER LEFT_PAREN

PARAMETER_DECLARATOR = 
 TYPE_SPECIFIER IDENTIFIER /
 TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION RIGHT_BRACKET

PARAMETER_DECLARATION = 
 PARAMETER_TYPE_QUALIFIER PARAMETER_QUALIFIER PARAMETER_DECLARATOR / 
 PARAMETER_QUALIFIER PARAMETER_DECLARATOR / 
 PARAMETER_TYPE_QUALIFIER PARAMETER_QUALIFIER PARAMETER_TYPE_SPECIFIER /
 PARAMETER_QUALIFIER PARAMETER_TYPE_SPECIFIER

PARAMETER_QUALIFIER = 
 /* EMPTY */
 IN / 
 OUT / 
 INOUT 

PARAMETER_TYPE_SPECIFIER = 
 TYPE_SPECIFIER

INIT_DECLARATOR_LIST = 
 SINGLE_DECLARATION /
 INIT_DECLARATOR_LIST COMMA IDENTIFIER / 
 INIT_DECLARATOR_LIST COMMA IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION / 
 RIGHT_BRACKET / 
 INIT_DECLARATOR_LIST COMMA IDENTIFIER LEFT_BRACKET / 
 RIGHT_BRACKET EQUAL INITIALIZER / 
 INIT_DECLARATOR_LIST COMMA IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION / 
 RIGHT_BRACKET EQUAL INITIALIZER / 
 INIT_DECLARATOR_LIST COMMA IDENTIFIER EQUAL INITIALIZER 

SINGLE_DECLARATION = 
 FULLY_SPECIFIED_TYPE / 
 FULLY_SPECIFIED_TYPE IDENTIFIER / 
 FULLY_SPECIFIED_TYPE IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION RIGHT_BRACKET / 
 FULLY_SPECIFIED_TYPE IDENTIFIER LEFT_BRACKET RIGHT_BRACKET EQUAL INITIALIZER / 
 FULLY_SPECIFIED_TYPE IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION / 
 RIGHT_BRACKET EQUAL INITIALIZER / 
 FULLY_SPECIFIED_TYPE IDENTIFIER EQUAL INITIALIZER / 
 INVARIANT IDENTIFIER
// GRAMMAR NOTE =  NO 'ENUM', OR 'TYPEDEF'.
FULLY_SPECIFIED_TYPE = 
 TYPE_SPECIFIER /
 TYPE_QUALIFIER TYPE_SPECIFIER

INVARIANT_QUALIFIER = 
 INVARIANT

INTERPOLATION_QUALIFIER = 
 SMOOTH / 
 FLAT

LAYOUT_QUALIFIER = 
 LAYOUT LEFT_PAREN LAYOUT_QUALIFIER_ID_LIST RIGHT_PAREN

LAYOUT_QUALIFIER_ID_LIST = 
 LAYOUT_QUALIFIER_ID /
 LAYOUT_QUALIFIER_ID_LIST COMMA LAYOUT_QUALIFIER_ID

LAYOUT_QUALIFIER_ID = 
 IDENTIFIER /
 IDENTIFIER EQUAL INTCONSTANT /
 IDENTIFIER EQUAL UINTCONSTANT 

PARAMETER_TYPE_QUALIFIER = 
 CONST 

TYPE_QUALIFIER = 
 STORAGE_QUALIFIER / 
 LAYOUT_QUALIFIER / 
 LAYOUT_QUALIFIER STORAGE_QUALIFIER / 
 INTERPOLATION_QUALIFIER STORAGE_QUALIFIER / 
 INTERPOLATION_QUALIFIER / 
 INVARIANT_QUALIFIER STORAGE_QUALIFIER / 
 INVARIANT_QUALIFIER INTERPOLATION_QUALIFIER STORAGE_QUALIFIER

STORAGE_QUALIFIER = 
 CONST / 
 IN / 
 OUT / 
 CENTROID IN / 
 CENTROID OUT / 
 UNIFORM

TYPE_SPECIFIER = 
 TYPE_SPECIFIER_NO_PREC / 
 PRECISION_QUALIFIER TYPE_SPECIFIER_NO_PREC

TYPE_SPECIFIER_NO_PREC = 
 TYPE_SPECIFIER_NONARRAY / 
 TYPE_SPECIFIER_NONARRAY LEFT_BRACKET RIGHT_BRACKET / 
 TYPE_SPECIFIER_NONARRAY LEFT_BRACKET CONSTANT_EXPRESSION RIGHT_BRACKET

TYPE_SPECIFIER_NONARRAY = 
 VOID / 
 FLOAT / 
 INT / 
 UINT / 
 BOOL / 
 VEC2 / 
 VEC3 / 
 VEC4 / 
 BVEC2 / 
 BVEC3 / 
 BVEC4  / 
 IVEC2 / 
 IVEC3 / 
 IVEC4 / 
 UVEC2 / 
 UVEC3 / 
 UVEC4 / 
 MAT2 / 
 MAT3 / 
 MAT4 / 
 MAT2X2 / 
 MAT2X3 / 
 MAT2X4 / 
 MAT3X2 / 
 MAT3X3 / 
 MAT3X4 / 
 MAT4X2 / 
 MAT4X3 / 
 MAT4X4 / 
 SAMPLER2D / 
 SAMPLER3D / 
 SAMPLERCUBE / 
 SAMPLER2DSHADOW / 
 SAMPLERCUBESHADOW / 
 SAMPLER2DARRAY / 
 SAMPLER2DARRAYSHADOW / 
 ISAMPLER2D / 
 ISAMPLER3D / 
 ISAMPLERCUBE / 
 ISAMPLER2DARRAY / 
 USAMPLER2D / 
 USAMPLER3D / 
 USAMPLERCUBE / 
 USAMPLER2DARRAY / 
 STRUCT_SPECIFIER / 
 TYPE_NAME

PRECISION_QUALIFIER = 
 HIGH_PRECISION / 
 MEDIUM_PRECISION / 
 LOW_PRECISION

STRUCT_SPECIFIER = 
 STRUCT IDENTIFIER LEFT_BRACE STRUCT_DECLARATION_LIST RIGHT_BRACE / 
 STRUCT LEFT_BRACE STRUCT_DECLARATION_LIST RIGHT_BRACE

STRUCT_DECLARATION_LIST = 
 STRUCT_DECLARATION / 
 STRUCT_DECLARATION_LIST STRUCT_DECLARATION

STRUCT_DECLARATION = 
 TYPE_SPECIFIER STRUCT_DECLARATOR_LIST SEMICOLON / 
 TYPE_QUALIFIER TYPE_SPECIFIER STRUCT_DECLARATOR_LIST SEMICOLON

STRUCT_DECLARATOR_LIST = 
 STRUCT_DECLARATOR / 
 STRUCT_DECLARATOR_LIST COMMA STRUCT_DECLARATOR

STRUCT_DECLARATOR = 
 IDENTIFIER / 
 IDENTIFIER LEFT_BRACKET RIGHT_BRACKET / 
 IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION RIGHT_BRACKET

INITIALIZER = 
 ASSIGNMENT_EXPRESSION

DECLARATION_STATEMENT = 
 DECLARATION

STATEMENT = 
 COMPOUND_STATEMENT_WITH_SCOPE / 
 SIMPLE_STATEMENT

STATEMENT_NO_NEW_SCOPE = 
 COMPOUND_STATEMENT_NO_NEW_SCOPE / 
 SIMPLE_STATEMENT

STATEMENT_WITH_SCOPE = 
 COMPOUND_STATEMENT_NO_NEW_SCOPE / 
 SIMPLE_STATEMENT

// GRAMMAR NOTE =  LABELED STATEMENTS FOR SWITCH ONLY; 'GOTO' IS NOT SUPPORTED.

SIMPLE_STATEMENT = 
 DECLARATION_STATEMENT / 
 EXPRESSION_STATEMENT / 
 SELECTION_STATEMENT / 
 SWITCH_STATEMENT / 
 CASE_LABEL / 
 ITERATION_STATEMENT / 
 JUMP_STATEMENT

COMPOUND_STATEMENT_WITH_SCOPE = 
 LEFT_BRACE RIGHT_BRACE / 
 oLEFT_BRACE STATEMENT_LIST RIGHT_BRACE

COMPOUND_STATEMENT_NO_NEW_SCOPE = 
 LEFT_BRACE RIGHT_BRACE / 
 LEFT_BRACE STATEMENT_LIST RIGHT_BRACE

STATEMENT_LIST = 
 STATEMENT / 
 STATEMENT_LIST STATEMENT

EXPRESSION_STATEMENT = 
 SEMICOLON / 
 EXPRESSION SEMICOLON

SELECTION_STATEMENT = 
 IF LEFT_PAREN EXPRESSION RIGHT_PAREN SELECTION_REST_STATEMENT

SELECTION_REST_STATEMENT = 
 STATEMENT_WITH_SCOPE ELSE STATEMENT_WITH_SCOPE / 
 STATEMENT_WITH_SCOPE

CONDITION = 
 EXPRESSION / 
 FULLY_SPECIFIED_TYPE IDENTIFIER EQUAL INITIALIZER

SWITCH_STATEMENT = 
SWITCH LEFT_PAREN EXPRESSION RIGHT_PAREN LEFT_BRACE SWITCH_STATEMENT_LIST / 
RIGHT_BRACE

SWITCH_STATEMENT_LIST = 
 /* NOTHING */
 STATEMENT_LIST

CASE_LABEL = 
 CASE EXPRESSION COLON / 
 DEFAULT COLON

ITERATION_STATEMENT = 
 WHILE LEFT_PAREN CONDITION RIGHT_PAREN STATEMENT_NO_NEW_SCOPE / 
 DO STATEMENT_WITH_SCOPE WHILE LEFT_PAREN EXPRESSION RIGHT_PAREN SEMICOLON / 
 FOR LEFT_PAREN FOR_INIT_STATEMENT FOR_REST_STATEMENT RIGHT_PAREN / 
 STATEMENT_NO_NEW_SCOPE

FOR_INIT_STATEMENT = 
 EXPRESSION_STATEMENT / 
 DECLARATION_STATEMENT

CONDITIONOPT = 
 CONDITION
 /* EMPTY */

FOR_REST_STATEMENT = 
 CONDITIONOPT SEMICOLON / 
 CONDITIONOPT SEMICOLON EXPRESSION

JUMP_STATEMENT = 
 CONTINUE SEMICOLON / 
 BREAK SEMICOLON / 
 RETURN SEMICOLON / 
 RETURN EXPRESSION SEMICOLON / 
 DISCARD SEMICOLON // FRAGMENT SHADER ONLY.
// GRAMMAR NOTE =  NO 'GOTO'. GOTOS ARE NOT SUPPORTED.

TRANSLATION_UNIT = 
 EXTERNAL_DECLARATION / 
 TRANSLATION_UNIT EXTERNAL_DECLARATION 

EXTERNAL_DECLARATION = 
 FUNCTION_DEFINITION / 
 DECLARATION

FUNCTION_DEFINITION = 
 FUNCTION_PROTOTYPE COMPOUND_STATEMENT_NO_NEW_SCOPE

/* IN GENERAL THE ABOVE GRAMMAR DESCRIBES A SUPER SET OF THE GLSL ES LANGUAGE. CERTAIN CONSTRUCTS THAT ARE
VALID PURELY IN TERMS OF THE GRAMMAR ARE DISALLOWED BY STATEMENTS ELSEWHERE IN THIS SPECIFICATION.
RULES SPECIFYING THE SCOPING ARE PRESENT ONLY TO ASSIST THE UNDERSTANDING OF SCOPING AND THEY DO NOT AFFECT
THE LANGUAGE ACCEPTED BY THE GRAMMAR. IF REQUIRED, THE GRAMMAR CAN BE SIMPLIFIED BY MAKING THE
FOLLOWING SUBSTITUTIONS = 
• REPLACE COMPOUND_STATEMENT_WITH_SCOPE AND COMPOUND_STATEMENT_NO_NEW_SCOPE WITH A NEW
RULE COMPOUND_STATEMENT
• REPLACE STATEMENT_WITH_SCOPE AND STATEMENT_NO_NEW_SCOPE WITH THE EXISTING RULE STATEMENT.*/
