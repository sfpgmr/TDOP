SOURCECHARACTER = .

WHITESPACE "whitespace"
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"
  / ZS

// Separator, Space
ZS = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

LINETERMINATOR
  = [\n\r\u2028\u2029]

LINETERMINATORSEQUENCE "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029"

COMMENT "comment"
  = MULTILINECOMMENT
  / SINGLELINECOMMENT

MULTILINECOMMENT
  = "/*" (!"*/" SOURCECHARACTER)* "*/"

MULTILINECOMMENTNOLINETERMINATOR
  = "/*" (!("*/" / LINETERMINATOR) SOURCECHARACTER)* "*/"

SINGLELINECOMMENT
  = "//" (!LINETERMINATOR SOURCECHARACTER)*

// Skipped
__
  = (WHITESPACE / LINETERMINATORSEQUENCE / COMMENT)*
_
  = (WHITESPACE / MULTILINECOMMENTNOLINETERMINATOR)*

// End of Statement
EOS
  = __ ";" 
 // _ SINGLELINECOMMENT? LINETERMINATORSEQUENCE
 // _ &"}" 
 // __ EOF

EOF  = !.


CONST = "const" 
BOOL = "bool"
FLOAT = "float"
INT = "int"
UINT = "uint"
BREAK = "break"
CONTINUE = "continue"
DO = "do"
ELSE = "else"
FOR = "for"
IF = "if"
DISCARD = "discard"
RETURN = "return"
SWITCH = "switch"
CASE = "case"
DEFAULT = "default"
BVEC2 = "bvec2"
BVEC3 = "bvec3"
BVEC4 = "bvec4"
IVEC2 = "ivec2"
IVEC3 = "ivec3"
IVEC4 = "ivec4"
UVEC2 = "uvec2"
UVEC3 = "uvec3"
UVEC4 = "uvec4"
VEC2 = "vec2"
VEC3 = "vec3"
VEC4 = "vec4"
MAT2 = "mat2"
MAT3 = "mat3"
MAT4 = "mat4"
CENTROID = "centroid"
IN = "in"
OUT = "out"
INOUT = "inout"
UNIFORM = "uniform"
FLAT = "flat"
SMOOTH = "smooth"
LAYOUT = "layout"
MAT2X2 = "mat2x2"
MAT2X3 = "mat2x3"
MAT2X4 = "mat2x4"
MAT3X2 = "mat3x2"
MAT3X3 = "mat3x3"
MAT3X4 = "mat3x4"
MAT4X2 = "mat4x2"
MAT4X3 = "mat4x3"
MAT4X4 = "mat4x4"
SAMPLER2D = "sampler2d"
SAMPLER3D = "sampler3d"
SAMPLERCUBE = "samplercube"
SAMPLER2DSHADOW = "sampler2dshadow"
SAMPLERCUBESHADOW = "samplercubeshadow"
SAMPLER2DARRAY = "sampler2darray"
SAMPLER2DARRAYSHADOW = "sampler2darrayshadow"
ISAMPLER2D = "isampler2d"
ISAMPLER3D = "isampler3d"
ISAMPLERCUBE = "isamplercube"
ISAMPLER2DARRAY = "isampler2darray"
USAMPLER2D = "usampler2d"
USAMPLER3D = "usampler3d"
USAMPLERCUBE = "usamplercube"
USAMPLER2DARRAY = "usampler2darray"

STRUCT = "struct"
VOID = "void"
WHILE = "while"
// 3.9 Identifiers
/*
識別子は、変数名、関数名、構造体名、およびフィールドセレクタに使用されます（フィールドセレクタは、5.5節「ベクトルコンポーネント」および5.6「マトリックスコンポーネント」で説明されているように、構造フィールドに似たベクトルと行列の要素を選択します）。
*/
IDENTIFIER = $(NONDIGIT (DIGIT / NONDIGIT)*)

NONDIGIT = [_a-zA-Z]

TYPE_NAME = "type_name"

FLOATING_CONSTANT = 
	FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX? /
  DIGIT_SEQUENCE EXPONENT_PART? FLOATING_SUFFIX?

FRACTIONAL_CONSTANT =
	DIGIT_SEQUENCE DOT DIGIT_SEQUENCE /
	DOT DIGIT_SEQUENCE /
	DIGIT_SEQUENCE DOT

FLOATING_SUFFIX = [fF]

SIGN = PLUS / MINUS

DIGIT_SEQUENCE = 
	$DIGIT+ 

EXPONENT_PART = [eE] SIGN? DIGIT_SEQUENCE

INTEGER_CONSTANT = 
	DECIMAL_CONSTANT /
	OCTAL_CONSTANT  /
	HEXADECIMAL_CONSTANT 

UINTEGER_CONSTANT = 
	DECIMAL_CONSTANT INTEGER_SUFFIX /
	OCTAL_CONSTANT INTEGER_SUFFIX /
	HEXADECIMAL_CONSTANT INTEGER_SUFFIX

INTEGER_SUFFIX = [uU]

DECIMAL_CONSTANT = 
	$(NONZERO_DIGIT DIGIT+) 

OCTAL_CONSTANT = "0" OCTAL_DIGIT+

HEXADECIMAL_CONSTANT = "0" [xX] HEXADECIMAL_DIGIT+

OCTAL_DIGIT = [0-7]
HEXADECIMAL_DIGIT = DIGIT / [a-fA-F]
DIGIT = '0' / NONZERO_DIGIT
NONZERO_DIGIT = [1-9]

BOOLCONSTANT = TRUE / FALSE

TRUE = "true"
FALSE = "false"

//フィールドセレクタは、5.5節「ベクトルコンポーネント」および5.6「マトリックスコンポーネント」で説明されているように、構造フィールドに似たベクトルと行列の要素を選択します
FIELD_SELECTION = "field_selection"

LEFT_OP = "<<"
RIGHT_OP = ">>"
INC_OP = "++"
DEC_OP = "--"
LE_OP = "<="
GE_OP = ">="
EQ_OP = "=="
NE_OP = "!="
AND_OP = "&&"
OR_OP = "||"
XOR_OP = "^^"
MUL_ASSIGN = "*="
DIV_ASSIGN = "/="
ADD_ASSIGN = "+="
MOD_ASSIGN = "%="
LEFT_ASSIGN = "<<="
RIGHT_ASSIGN = ">>="
AND_ASSIGN = "&="
XOR_ASSIGN = "^="
OR_ASSIGN = "|="
SUB_ASSIGN = "-="
LEFT_PAREN = "("
RIGHT_PAREN = ")"
LEFT_BRACKET = "["
RIGHT_BRACKET = "]"
LEFT_BRACE = "{"
RIGHT_BRACE = "}"
DOT = "."
COMMA = ","
COLON = ":"
EQUAL = "="
SEMICOLON = ";"
BANG = "!"
DASH = "'"
TILDE = "~"
PLUS = "+"
MINUS = "-"
STAR = "*"
SLASH = "/"
PERCENT = "%"
LEFT_ANGLE = "<"
RIGHT_ANGLE = ">"
VERTICAL_BAR = "_"
CARET = "^"
AMPERSAND = "&"
QUESTION = "?"
INVARIANT = "invariant"
HIGH_PRECISION = "highp"
MEDIUM_PRECISION = "mediump"
LOW_PRECISION = "lowp"
PRECISION = "precision"

VARIABLE_IDENTIFIER = IDENTIFIER

PRIMARY_EXPRESSION =
 VARIABLE_IDENTIFIER /
 INTEGER_CONSTANT / 
 UINTEGER_CONSTANT / 
 FLOATING_CONSTANT / 
 BOOLCONSTANT / 
 LEFT_PAREN __ EXPRESSION __ RIGHT_PAREN 

POSTFIX_EXPRESSION =
 PRIMARY_EXPRESSION / 
 FUNCTION_CALL /   
 ((PRIMARY_EXPRESSION /  FUNCTION_CALL)   
  (LEFT_BRACKET __ INTEGER_EXPRESSION __ RIGHT_BRACKET / 
  __ DOT __ FIELD_SELECTION / 
  __ INC_OP / 
  __ DEC_OP)*)

INTEGER_EXPRESSION = 
 EXPRESSION

FUNCTION_CALL = 
 FUNCTION_CALL_OR_METHOD

FUNCTION_CALL_OR_METHOD = 
 FUNCTION_CALL_GENERIC / 
 POSTFIX_EXPRESSION __ DOT __ FUNCTION_CALL_GENERIC

FUNCTION_CALL_GENERIC = 
 FUNCTION_CALL_HEADER_WITH_PARAMETERS __ RIGHT_PAREN / 
 FUNCTION_CALL_HEADER_NO_PARAMETERS __ RIGHT_PAREN

FUNCTION_CALL_HEADER_NO_PARAMETERS = 
 FUNCTION_CALL_HEADER __ VOID /
 FUNCTION_CALL_HEADER

FUNCTION_CALL_HEADER_WITH_PARAMETERS = 
 FUNCTION_CALL_HEADER __ ASSIGNMENT_EXPRESSION / 
 FUNCTION_CALL_HEADER_WITH_PARAMETERS __ COMMA __ ASSIGNMENT_EXPRESSION

FUNCTION_CALL_HEADER = 
 FUNCTION_IDENTIFIER LEFT_PAREN
// Grammar Note =  Constructors look like functions, but lexical analysis recognized most of them as
// keywords. They are now recognized through “type_specifier”.
// Methods (.length) and identifiers are recognized through postfix_expression.

FUNCTION_IDENTIFIER = 
 TYPE_SPECIFIER / 
 IDENTIFIER / 
 FIELD_SELECTION 

UNARY_EXPRESSION = 
 POSTFIX_EXPRESSION / 
 INC_OP UNARY_EXPRESSION / 
 DEC_OP UNARY_EXPRESSION / 
 UNARY_OPERATOR __ UNARY_EXPRESSION

// Grammar Note =  No traditional style type casts.

UNARY_OPERATOR = 
 PLUS / 
 DASH /
 BANG /
 TILDE

// Grammar Note =  No '*' or '&' unary ops. Pointers are not supported.
MULTIPLICATIVE_EXPRESSION = 
 UNARY_EXPRESSION  ( __ (STAR / SLASH / PERCENT) __ UNARY_EXPRESSION )*  

ADDITIVE_EXPRESSION = 
 MULTIPLICATIVE_EXPRESSION ( __ PLUS / DASH __ MULTIPLICATIVE_EXPRESSION)*

SHIFT_EXPRESSION = 
 ADDITIVE_EXPRESSION ( __ LEFT_OP / RIGHT_OP __ ADDITIVE_EXPRESSION)* 

RELATIONAL_EXPRESSION = 
 SHIFT_EXPRESSION  ( __ (LEFT_ANGLE / LE_OP / GE_OP) __ SHIFT_EXPRESSION)*

EQUALITY_EXPRESSION = 
 RELATIONAL_EXPRESSION ( __ (EQ_OP / NE_OP) __ RELATIONAL_EXPRESSION)*

AND_EXPRESSION = 
 EQUALITY_EXPRESSION ( __ AMPERSAND __ EQUALITY_EXPRESSION )*

EXCLUSIVE_OR_EXPRESSION = 
 AND_EXPRESSION (__ CARET __ AND_EXPRESSION)*

INCLUSIVE_OR_EXPRESSION = 
 EXCLUSIVE_OR_EXPRESSION ( __ VERTICAL_BAR __ EXCLUSIVE_OR_EXPRESSION)*

LOGICAL_AND_EXPRESSION = 
 INCLUSIVE_OR_EXPRESSION ( __ AND_OP __ INCLUSIVE_OR_EXPRESSION)*

LOGICAL_XOR_EXPRESSION = 
 LOGICAL_AND_EXPRESSION ( __ XOR_OP __ LOGICAL_AND_EXPRESSION)*

LOGICAL_OR_EXPRESSION = 
 LOGICAL_XOR_EXPRESSION ( __ OR_OP __ LOGICAL_XOR_EXPRESSION)*

CONDITIONAL_EXPRESSION = 
 LOGICAL_OR_EXPRESSION  __ QUESTION __ EXPRESSION __ COLON __ ASSIGNMENT_EXPRESSION 

ASSIGNMENT_EXPRESSION = 
 CONDITIONAL_EXPRESSION / 
 UNARY_EXPRESSION ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION

ASSIGNMENT_OPERATOR = 
 EQUAL / 
 MUL_ASSIGN / 
 DIV_ASSIGN / 
 MOD_ASSIGN / 
 ADD_ASSIGN / 
 SUB_ASSIGN / 
 LEFT_ASSIGN / 
 RIGHT_ASSIGN / 
 AND_ASSIGN / 
 XOR_ASSIGN / 
 OR_ASSIGN

EXPRESSION = 
 ASSIGNMENT_EXPRESSION  ( __  COMMA __ ASSIGNMENT_EXPRESSION)*

CONSTANT_EXPRESSION = 
 CONDITIONAL_EXPRESSION

DECLARATION = 
 FUNCTION_PROTOTYPE __ SEMICOLON / 
 INIT_DECLARATOR_LIST __ SEMICOLON / 
 PRECISION __ PRECISION_QUALIFIER __ TYPE_SPECIFIER_NO_PREC __ SEMICOLON / 
 TYPE_QUALIFIER __ IDENTIFIER __ LEFT_BRACE __ STRUCT_DECLARATION_LIST __ RIGHT_BRACE __ SEMICOLON / 
 TYPE_QUALIFIER __ IDENTIFIER __ LEFT_BRACE __ STRUCT_DECLARATION_LIST __ RIGHT_BRACE / 
 IDENTIFIER __ SEMICOLON / 
 TYPE_QUALIFIER __ IDENTIFIER __ LEFT_BRACE __ STRUCT_DECLARATION_LIST __ RIGHT_BRACE / 
 IDENTIFIER __ LEFT_BRACKET __ CONSTANT_EXPRESSION __ RIGHT_BRACKET __ SEMICOLON / 
 TYPE_QUALIFIER __ SEMICOLON

FUNCTION_PROTOTYPE = 
 FUNCTION_DECLARATOR __ RIGHT_PAREN

FUNCTION_DECLARATOR = 
  FUNCTION_HEADER /
  FUNCTION_HEADER_WITH_PARAMETERS

FUNCTION_HEADER_WITH_PARAMETERS = 
 FUNCTION_HEADER __ PARAMETER_DECLARATION /
 FUNCTION_HEADER_WITH_PARAMETERS __ COMMA __ PARAMETER_DECLARATION

FUNCTION_HEADER = 
 FULLY_SPECIFIED_TYPE __ IDENTIFIER __ LEFT_PAREN

PARAMETER_DECLARATOR = 
 TYPE_SPECIFIER __ IDENTIFIER /
 TYPE_SPECIFIER __ IDENTIFIER __ LEFT_BRACKET __ CONSTANT_EXPRESSION __ RIGHT_BRACKET

PARAMETER_DECLARATION = 
 PARAMETER_TYPE_QUALIFIER __ PARAMETER_QUALIFIER __ PARAMETER_DECLARATOR / 
 PARAMETER_QUALIFIER __ PARAMETER_DECLARATOR / 
 PARAMETER_TYPE_QUALIFIER __ PARAMETER_QUALIFIER __ PARAMETER_TYPE_SPECIFIER /
 PARAMETER_QUALIFIER __ PARAMETER_TYPE_SPECIFIER

PARAMETER_QUALIFIER = 
 /* EMPTY */
 IN / 
 OUT / 
 INOUT 

PARAMETER_TYPE_SPECIFIER = 
 TYPE_SPECIFIER

INIT_DECLARATOR_LIST = 
 SINGLE_DECLARATION ( __ COMMA __ IDENTIFIER (__ LEFT_BRACKET __ (CONSTANT_EXPRESSION __)?  RIGHT_BRACKET)? ( __ EQUAL __ INITIALIZER)?)*

SINGLE_DECLARATION = 
 FULLY_SPECIFIED_TYPE / 
 FULLY_SPECIFIED_TYPE IDENTIFIER / 
 FULLY_SPECIFIED_TYPE IDENTIFIER LEFT_BRACKET CONSTANT_EXPRESSION RIGHT_BRACKET / 
 FULLY_SPECIFIED_TYPE IDENTIFIER LEFT_BRACKET RIGHT_BRACKET EQUAL INITIALIZER / 
 FULLY_SPECIFIED_TYPE IDENTIFIER? (LEFT_BRACKET CONSTANT_EXPRESSION? RIGHT_BRACKET EQUAL INITIALIZER / 
 FULLY_SPECIFIED_TYPE IDENTIFIER EQUAL INITIALIZER / 
 INVARIANT IDENTIFIER
// GRAMMAR NOTE =  NO 'ENUM', OR 'TYPEDEF'.
FULLY_SPECIFIED_TYPE = 
 TYPE_SPECIFIER /
 TYPE_QUALIFIER TYPE_SPECIFIER

INVARIANT_QUALIFIER = 
 INVARIANT

INTERPOLATION_QUALIFIER = 
 SMOOTH / 
 FLAT

LAYOUT_QUALIFIER = 
 LAYOUT LEFT_PAREN LAYOUT_QUALIFIER_ID_LIST RIGHT_PAREN

LAYOUT_QUALIFIER_ID_LIST = 
 LAYOUT_QUALIFIER_ID /
 LAYOUT_QUALIFIER_ID_LIST COMMA LAYOUT_QUALIFIER_ID

LAYOUT_QUALIFIER_ID = 
 IDENTIFIER /
 IDENTIFIER EQUAL INTEGER_CONSTANT /
 IDENTIFIER EQUAL UINTEGER_CONSTANT 

PARAMETER_TYPE_QUALIFIER = 
 CONST 

TYPE_QUALIFIER = 
 STORAGE_QUALIFIER / 
 LAYOUT_QUALIFIER / 
 LAYOUT_QUALIFIER STORAGE_QUALIFIER / 
 INTERPOLATION_QUALIFIER STORAGE_QUALIFIER / 
 INTERPOLATION_QUALIFIER / 
 INVARIANT_QUALIFIER STORAGE_QUALIFIER / 
 INVARIANT_QUALIFIER INTERPOLATION_QUALIFIER STORAGE_QUALIFIER

STORAGE_QUALIFIER = 
 CONST / 
 IN / 
 OUT / 
 CENTROID IN / 
 CENTROID OUT / 
 UNIFORM

TYPE_SPECIFIER = 
 TYPE_SPECIFIER_NO_PREC / 
 PRECISION_QUALIFIER TYPE_SPECIFIER_NO_PREC

TYPE_SPECIFIER_NO_PREC = 
 TYPE_SPECIFIER_NONARRAY / 
 TYPE_SPECIFIER_NONARRAY LEFT_BRACKET RIGHT_BRACKET / 
 TYPE_SPECIFIER_NONARRAY LEFT_BRACKET CONSTANT_EXPRESSION RIGHT_BRACKET

TYPE_SPECIFIER_NONARRAY = 
 VOID / 
 FLOAT / 
 INT / 
 UINT / 
 BOOL / 
 VEC2 / 
 VEC3 / 
 VEC4 / 
 BVEC2 / 
 BVEC3 / 
 BVEC4  / 
 IVEC2 / 
 IVEC3 / 
 IVEC4 / 
 UVEC2 / 
 UVEC3 / 
 UVEC4 / 
 MAT2 / 
 MAT3 / 
 MAT4 / 
 MAT2X2 / 
 MAT2X3 / 
 MAT2X4 / 
 MAT3X2 / 
 MAT3X3 / 
 MAT3X4 / 
 MAT4X2 / 
 MAT4X3 / 
 MAT4X4 / 
 SAMPLER2D / 
 SAMPLER3D / 
 SAMPLERCUBE / 
 SAMPLER2DSHADOW / 
 SAMPLERCUBESHADOW / 
 SAMPLER2DARRAY / 
 SAMPLER2DARRAYSHADOW / 
 ISAMPLER2D / 
 ISAMPLER3D / 
 ISAMPLERCUBE / 
 ISAMPLER2DARRAY / 
 USAMPLER2D / 
 USAMPLER3D / 
 USAMPLERCUBE / 
 USAMPLER2DARRAY / 
 STRUCT_SPECIFIER / 
 TYPE_NAME

PRECISION_QUALIFIER = 
 HIGH_PRECISION / 
 MEDIUM_PRECISION / 
 LOW_PRECISION

STRUCT_SPECIFIER = 
 STRUCT __ IDENTIFIER __ LEFT_BRACE __ STRUCT_DECLARATION_LIST __ RIGHT_BRACE / 
 STRUCT __ LEFT_BRACE __ STRUCT_DECLARATION_LIST __ RIGHT_BRACE

STRUCT_DECLARATION_LIST = 
 STRUCT_DECLARATION / 
 STRUCT_DECLARATION_LIST __ STRUCT_DECLARATION

STRUCT_DECLARATION = 
 TYPE_SPECIFIER __ STRUCT_DECLARATOR_LIST __ SEMICOLON / 
 TYPE_QUALIFIER __ TYPE_SPECIFIER __ STRUCT_DECLARATOR_LIST __ SEMICOLON

STRUCT_DECLARATOR_LIST = 
 STRUCT_DECLARATOR ( __ COMMA __ STRUCT_DECLARATOR )*

STRUCT_DECLARATOR = 
 // 変数
 IDENTIFIER / 
 // 配列変数
 IDENTIFIER __ LEFT_BRACKET __ RIGHT_BRACKET / 
 IDENTIFIER __ LEFT_BRACKET __ CONSTANT_EXPRESSION __ RIGHT_BRACKET

INITIALIZER = 
 ASSIGNMENT_EXPRESSION

DECLARATION_STATEMENT = 
 DECLARATION

STATEMENT = 
 COMPOUND_STATEMENT_WITH_SCOPE / 
 SIMPLE_STATEMENT

STATEMENT_NO_NEW_SCOPE = 
 COMPOUND_STATEMENT_NO_NEW_SCOPE / 
 SIMPLE_STATEMENT

STATEMENT_WITH_SCOPE = 
 COMPOUND_STATEMENT_NO_NEW_SCOPE / 
 SIMPLE_STATEMENT

// GRAMMAR NOTE =  LABELED STATEMENTS FOR SWITCH ONLY; 'GOTO' IS NOT SUPPORTED.

SIMPLE_STATEMENT = 
 DECLARATION_STATEMENT / 
 EXPRESSION_STATEMENT / 
 SELECTION_STATEMENT / 
 SWITCH_STATEMENT / 
 CASE_LABEL / 
 ITERATION_STATEMENT / 
 JUMP_STATEMENT

COMPOUND_STATEMENT_WITH_SCOPE = 
 LEFT_BRACE RIGHT_BRACE / 
 oLEFT_BRACE STATEMENT_LIST RIGHT_BRACE

COMPOUND_STATEMENT_NO_NEW_SCOPE = 
 LEFT_BRACE RIGHT_BRACE / 
 LEFT_BRACE STATEMENT_LIST RIGHT_BRACE

STATEMENT_LIST = 
 STATEMENT / 
 STATEMENT_LIST STATEMENT

EXPRESSION_STATEMENT = 
 SEMICOLON / 
 EXPRESSION SEMICOLON

SELECTION_STATEMENT = 
 IF LEFT_PAREN EXPRESSION RIGHT_PAREN SELECTION_REST_STATEMENT

SELECTION_REST_STATEMENT = 
 STATEMENT_WITH_SCOPE ELSE STATEMENT_WITH_SCOPE / 
 STATEMENT_WITH_SCOPE

CONDITION = 
 EXPRESSION / 
 FULLY_SPECIFIED_TYPE IDENTIFIER EQUAL INITIALIZER

SWITCH_STATEMENT = 
SWITCH LEFT_PAREN EXPRESSION RIGHT_PAREN LEFT_BRACE SWITCH_STATEMENT_LIST / 
RIGHT_BRACE

SWITCH_STATEMENT_LIST = 
 /* NOTHING */
 STATEMENT_LIST

CASE_LABEL = 
 CASE EXPRESSION COLON / 
 DEFAULT COLON

ITERATION_STATEMENT = 
 WHILE LEFT_PAREN CONDITION RIGHT_PAREN STATEMENT_NO_NEW_SCOPE / 
 DO STATEMENT_WITH_SCOPE WHILE LEFT_PAREN EXPRESSION RIGHT_PAREN SEMICOLON / 
 FOR LEFT_PAREN FOR_INIT_STATEMENT FOR_REST_STATEMENT RIGHT_PAREN / 
 STATEMENT_NO_NEW_SCOPE

FOR_INIT_STATEMENT = 
 EXPRESSION_STATEMENT / 
 DECLARATION_STATEMENT

CONDITIONOPT = 
 CONDITION
 /* EMPTY */

FOR_REST_STATEMENT = 
 CONDITIONOPT SEMICOLON / 
 CONDITIONOPT SEMICOLON EXPRESSION

JUMP_STATEMENT = 
 CONTINUE SEMICOLON / 
 BREAK SEMICOLON / 
 RETURN SEMICOLON / 
 RETURN EXPRESSION SEMICOLON / 
 DISCARD SEMICOLON // FRAGMENT SHADER ONLY.
// GRAMMAR NOTE =  NO 'GOTO'. GOTOS ARE NOT SUPPORTED.

TRANSLATION_UNIT = 
 EXTERNAL_DECLARATION / 
 TRANSLATION_UNIT EXTERNAL_DECLARATION 

EXTERNAL_DECLARATION = 
 FUNCTION_DEFINITION / 
 DECLARATION

FUNCTION_DEFINITION = 
 FUNCTION_PROTOTYPE COMPOUND_STATEMENT_NO_NEW_SCOPE

/* IN GENERAL THE ABOVE GRAMMAR DESCRIBES A SUPER SET OF THE GLSL ES LANGUAGE. CERTAIN CONSTRUCTS THAT ARE
VALID PURELY IN TERMS OF THE GRAMMAR ARE DISALLOWED BY STATEMENTS ELSEWHERE IN THIS SPECIFICATION.
RULES SPECIFYING THE SCOPING ARE PRESENT ONLY TO ASSIST THE UNDERSTANDING OF SCOPING AND THEY DO NOT AFFECT
THE LANGUAGE ACCEPTED BY THE GRAMMAR. IF REQUIRED, THE GRAMMAR CAN BE SIMPLIFIED BY MAKING THE
FOLLOWING SUBSTITUTIONS = 
• REPLACE COMPOUND_STATEMENT_WITH_SCOPE AND COMPOUND_STATEMENT_NO_NEW_SCOPE WITH A NEW
RULE COMPOUND_STATEMENT
• REPLACE STATEMENT_WITH_SCOPE AND STATEMENT_NO_NEW_SCOPE WITH THE EXISTING RULE STATEMENT.*/
